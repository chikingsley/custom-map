# Auto Custom Map Pipeline - Status & Plan

* *Date:** Saturday, December 27th, 2024 @ 3:17 PM
* *Context:** Analysis of previous agent conversation + codebase review

- --

## Executive Summary

The goal is to **find the exact location on a map where a construction project is happening**and**align the drawing with the actual map**. This requires a multi-source approach because:
- PDFs contain MANY addresses (contractor, developer, engineer, actual site)
- You can't just pull a random address - need to verify through multiple signals
- Cross-streets, intersections, project names, grounding all provide location hints
- The final location should be determined by CONSENSUS across multiple data sources

- --

## Current State vs. Vision

### What's Built (Individual Pieces Work)

| Component | File | Status |
|-----------|------|--------|
| PDF page scanning | `src/server/lib/pdf.ts` | ✅ Finds site plan pages |
| AI extraction | `src/server/lib/gemini.ts` | ✅ Extracts data from image |
| Geocoding | `src/server/lib/geocoding.ts` | ✅ Address → coords |
| Intersection geocoding | `src/server/lib/geocoding.ts` | ✅ "Road1 & Road2" → coords |
| Parcel lookup | `src/server/lib/maricopa.ts` | ✅ Coords → parcel polygon |
| Road geometry | `src/server/lib/roads.ts` | ✅ Road name → polyline |

### What's Missing (Orchestration Layer)

| Component | Status | Description |
|-----------|--------|-------------|
| Multi-candidate extraction | ❌ | Extract MANY potential addresses/locations, not just one |
| Multi-source geocoding loop | ❌ | Geocode ALL intersections, project name, roads+city |
| Multi-point parcel lookup | ❌ | Look up parcels at EVERY geocoded coordinate |
| Clustering algorithm | ❌ | Group nearby coordinates together |
| Outlier removal | ❌ | Discard coordinates that are way off |
| Consensus scoring | ❌ | "This parcel appeared 5 times" = high confidence |
| Re-ranking | ❌ | Sort results by confidence/frequency |
| Road tracing from drawing | ❌ | Extract actual road paths from the PDF drawing |

- --

## The Problem Illustrated

```text
Current Pipeline (Single-Point):
  PDF → Extract ONE address → Geocode → ONE parcel → Done

  Problem: What if that address is the contractor's office in Phoenix,
           not the actual site in Sun City?

Needed Pipeline (Multi-Source):
  PDF → Extract MANY signals:
        ├── Address candidate 1 (title block)
        ├── Address candidate 2 (found elsewhere)
        ├── Intersection 1: "99th Ave & Bell Rd"
        ├── Intersection 2: "99th Ave & Thunderbird"
        ├── Project name: "Sun Health La Loma Campus"
        └── Roads: ["99th Ave", "Boswell Blvd", ...]

      → Geocode ALL of these → Get 8 different coordinates
      → Look up parcels at all 8 coordinates
      → Cluster: "7 of 8 coords are within 0.5 miles of each other"
      → Remove outlier: "1 coord is 20 miles away (contractor office)"
      → Consensus: "Parcel 123-45-678 appeared in 5 lookups"
      → Result: HIGH CONFIDENCE location

```text

- --

## Proposed Architecture

### New Types Needed

```typescript
// A single location signal from any source
type LocationSignal = {
  source: "address" | "intersection" | "project_grounding" | "road_grounding";
  query: string;           // What we searched for
  coords: LatLng | null;   // Result (null if geocode failed)
  confidence: number;      // 0-1, how reliable is this source
  rawResponse?: unknown;   // Keep original response for debugging
};

// Parcel with hit tracking
type ParcelCandidate = ParcelData & {
  hitCount: number;        // How many signals pointed here
  signalSources: string[]; // Which signals led to this parcel
};

// Cluster of nearby coordinates
type LocationCluster = {
  centroid: LatLng;
  signals: LocationSignal[];
  radius: number;          // How spread out are the points
  totalConfidence: number; // Sum of signal confidences
};

// Final aggregated result
type AggregatedLocationResult = {
  // All raw signals collected
  signals: LocationSignal[];

  // Clustering results
  clusters: LocationCluster[];
  primaryCluster: LocationCluster | null;
  outliers: LocationSignal[];

  // Parcel candidates ranked by frequency
  parcels: ParcelCandidate[];
  primaryParcel: ParcelCandidate | null;

  // Road geometries for display
  roads: RoadGeometry[];

  // Final verdict
  consensusLocation: LatLng | null;
  consensusConfidence: number;

  // Debug info
  processingLog: string[];
};

```text

### New Pipeline Function

```typescript
// src/server/lib/pipeline.ts

async function runLocationPipeline(
  extractedData: ExtractedPlanData,
  options?: { maxSignals?: number; clusterRadiusMeters?: number }
): Promise<AggregatedLocationResult> {

  const signals: LocationSignal[] = [];

  // 1. Geocode the address (if found)
  if (extractedData.address) {
    const result = await geocodeAddress(fullAddress);
    signals.push({ source: "address", query: fullAddress, coords: result, ... });
  }

  // 2. Geocode EVERY intersection
  for (const intersection of extractedData.intersections) {
    const query = `${intersection.road1} and ${intersection.road2}`;
    const result = await geocodeIntersection(intersection.road1, intersection.road2, city);
    signals.push({ source: "intersection", query, coords: result, ... });
  }

  // 3. Ground-search the project name
  if (extractedData.projectName) {
    const result = await groundSearch(extractedData.projectName);
    signals.push({ source: "project_grounding", query: extractedData.projectName, coords: result, ... });
  }

  // 4. Ground-search roads + city
  for (const road of extractedData.roads) {
    const query = `${road.name}, ${extractedData.city}, ${extractedData.state}`;
    const result = await groundSearch(query);
    signals.push({ source: "road_grounding", query, coords: result, ... });
  }

  // 5. Cluster the signals
  const { clusters, outliers } = clusterSignals(signals, options.clusterRadiusMeters);

  // 6. Look up parcels at each cluster centroid
  const parcels: ParcelCandidate[] = [];
  for (const cluster of clusters) {
    const parcel = await queryParcelByCoordinates(cluster.centroid);
    if (parcel) {
      // Check if we already have this parcel
      const existing = parcels.find(p => p.apn === parcel.apn);
      if (existing) {
        existing.hitCount++;
        existing.signalSources.push(...cluster.signals.map(s => s.source));
      } else {
        parcels.push({ ...parcel, hitCount: 1, signalSources: [...] });
      }
    }
  }

  // 7. Rank parcels by hit count
  parcels.sort((a, b) => b.hitCount - a.hitCount);

  // 8. Get road geometries
  const roads = await Promise.all(
    extractedData.roads.map(r => getRoadGeometryByName(r.name, city, state))
  );

  // 9. Determine consensus
  const primaryCluster = clusters[0]; // Highest confidence cluster
  const primaryParcel = parcels[0];   // Most frequently hit parcel

  return {
    signals,
    clusters,
    primaryCluster,
    outliers,
    parcels,
    primaryParcel,
    roads: roads.filter(Boolean),
    consensusLocation: primaryCluster?.centroid ?? null,
    consensusConfidence: calculateConfidence(primaryCluster, primaryParcel),
    processingLog: [...],
  };
}

```text

### Clustering Algorithm

```typescript
function clusterSignals(
  signals: LocationSignal[],
  radiusMeters: number = 500
): { clusters: LocationCluster[]; outliers: LocationSignal[] } {

  const validSignals = signals.filter(s => s.coords !== null);
  const clusters: LocationCluster[] = [];
  const used = new Set<number>();

  for (let i = 0; i < validSignals.length; i++) {
    if (used.has(i)) continue;

    const cluster: LocationSignal[] = [validSignals[i]];
    used.add(i);

    // Find all signals within radius
    for (let j = i + 1; j < validSignals.length; j++) {
      if (used.has(j)) continue;

      const distance = haversineDistance(
        validSignals[i].coords!,
        validSignals[j].coords!
      );

      if (distance <= radiusMeters) {
        cluster.push(validSignals[j]);
        used.add(j);
      }
    }

    // Calculate cluster centroid
    const centroid = calculateCentroid(cluster.map(s => s.coords!));

    clusters.push({
      centroid,
      signals: cluster,
      radius: calculateMaxRadius(centroid, cluster),
      totalConfidence: cluster.reduce((sum, s) => sum + s.confidence, 0),
    });
  }

  // Sort clusters by total confidence (most signals = highest confidence)
  clusters.sort((a, b) => b.totalConfidence - a.totalConfidence);

  // Signals that didn't cluster with anything are outliers
  const outliers = signals.filter((_, i) => !used.has(i));

  return { clusters, outliers };
}

```text

- --

## Implementation Tasks

### Phase 1: Types & Core Pipeline

1. [ ] Add new types to `src/types.ts` (LocationSignal, ParcelCandidate, etc.)
2. [ ] Create `src/server/lib/pipeline.ts` with `runLocationPipeline()`
3. [ ] Implement `clusterSignals()` with Haversine distance
4. [ ] Implement confidence scoring

### Phase 2: Enhanced Extraction

5. [ ] Update extraction prompt to return MULTIPLE address candidates
6. [ ] Add "address_context" field (e.g., "title block", "contractor info")
7. [ ] Extract MORE intersections (not just corners of site)

### Phase 3: Multi-Source Geocoding

8. [ ] Add `groundSearch()` function for project name lookup
9. [ ] Loop through all intersections in pipeline
10. [ ] Loop through roads + city combinations

### Phase 4: Aggregation & Ranking

11. [ ] Implement parcel hit counting
12. [ ] Implement outlier detection (>2 std dev from centroid)
13. [ ] Implement final confidence score calculation

### Phase 5: Testing with Real PDF

14. [ ] Actually analyze Sun Health PDF
15. [ ] Run full pipeline
16. [ ] Verify consensus matches expected location

### Phase 6: Frontend (Later)

17. [ ] Display all signals on map with source labels
18. [ ] Highlight primary cluster
19. [ ] Show parcel candidates with hit counts
20. [ ] Allow user to confirm/reject suggestions

- --

## Open Questions

1. **How aggressive should outlier removal be?**
    - Option A: Remove anything >1 mile from largest cluster
    - Option B: Remove anything >2 standard deviations
    - Option C: Keep everything, just rank by cluster size

2. **What confidence weights per source?**
    - Address geocode: 0.9 (if from title block)
    - Intersection geocode: 0.7
    - Project name grounding: 0.6
    - Road + city grounding: 0.4

3. **Parcel coverage issue**
    - Sun City returned null (outside Maricopa parcel layer coverage)
    - Need fallback: Pinal County? Different data source?

- --

## Next Session Options

* *Option 1: Analyze the actual PDF first**
- Upload Sun Health PDF to Gemini
- See what data is actually extractable
- Validate assumptions about what's in there

* *Option 2: Build the pipeline architecture**
- Implement types and core functions
- Get the multi-source loop working
- Test with mock data

* *Option 3: Both (recommended)**
- Quick PDF analysis to understand real data
- Then build pipeline informed by actual content

- --

## Files Reference

```text
src/
├── types.ts                    # Add new aggregation types here
├── server/
│   ├── index.ts               # Main server (exists)
│   ├── lib/
│   │   ├── gemini.ts          # AI extraction (exists, needs multi-candidate)
│   │   ├── pdf.ts             # PDF scanning (exists, works)
│   │   ├── geocoding.ts       # Geocoding (exists, works)
│   │   ├── roads.ts           # Road geometry (exists, works)
│   │   ├── maricopa.ts        # Parcel lookup (exists, works)
│   │   ├── pipeline.ts        # NEW: Orchestration layer
│   │   ├── clustering.ts      # NEW: Clustering algorithm
│   │   └── grounding.ts       # NEW: Project name / road grounding
│   └── routes/
│       └── pipeline.ts        # NEW: POST /api/pipeline/run

```text

- --

## Summary

* *The individual tools work. The orchestration that ties them together for multi-source consensus doesn't exist yet.**

The previous agent tested single-point lookups and assumed an address. Your vision requires looping through multiple signals, clustering them, finding consensus, and building confidence from agreement across sources.

This document captures that gap and provides a roadmap to close it.
